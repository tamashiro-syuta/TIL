---
title: "Goのイテレータ深堀りNight"
tags: [勉強会, Go]
---

# まずはイテレータ（range over func）の仕様を学ぼう
- `for range`で関数が指定できるようになった
  - これまでは先頭から探索してたが、いてレーションの仕方が柔軟になったよ、後方探索とかできる
  - 重要な3つの仕様
      1. for rangeに指定した関数が一度だけ実行される
      2. yield関数を呼ぶとfor文のボディに処理が映る
      3. hoge
![`for range`で関数が指定](/image/event/for_range_func_example.png)

# 利用者視点で考える、イテレータとの上手な付き合い方
- 利用者：イテレータで実装されたものを使う人
  - どうやって使うの？どこまでイテレータの知識が必要？
  - 実装方法までは知らなくて良い
  - 言語使用の変更、イテレータの使い方は知っておくべき
- Goのイテレータ : 任意のデータ構造(二分木、OrderedMap)を対象にrangeループが使えるようにできる
- イテレータとSliceとの違い
  - Go1.22までは、Sliceが一番柔軟だった
  - メモリ効率
    - sliceは保持する文は最低限必要
    - イテレータはただの関数なので、メモリ効率が良い
  - データの終端
    - 終端処理を明示的にできる
- slice/mapの変換も。slice/map なんちゃらのパッケージが用意されている。その他の操作も大体ある

# 標準ライブラリの動向とイテレータのパフォーマンス
- [スライド](https://speakerdeck.com/makki_d/biao-zhun-raiburarinodong-xiang-toiteretanopahuomansu?slide=5)
- 見ておくべきプロポーザル
  - [iter: new package for iterators](https://github.com/golang/go/issues/61897)
  - これ、入れようぜ的なやつらしい
- Go 1.23.0で使えるようになったもの
- 使えるようになりそうなもの
  - bytes, strings
    - 分割後のスライスを構築することなく反復処理
    - メモリ効率が良い
  - regexp
    - FindAllなどのように複数のマッチ結果をスライスで返すもののイテレータ版
- 準標準パッケージ
  - golang.org/x/exp/xiter
    - イテレータを介してシーケンスに対する汎用処理を提供

- イテレータのパフォーマンス

# イテレータを実装する時に知っておいた方が良いこと
- 聞き入ってて、メモできなかったから、あとでスライド共有されたら貼る
- `t.Helper()`では、関数が1段階深くなってテストがpanicを起こすため、Sliceに直してするのがおすすめ

# teratorでページネーションを実現する
- iteratorは、ページネーションにも使える
- イテレータにbreakやページの更新などを隠蔽することで、書き忘れなども減らせる
  - 以前は、独自のlintを実装していたらしい
- ページネーション以外でもループを抽象化する用途で使える
- イテレータは直感的に読みにくいので、隠蔽したいとこがあれば使うとかで良さそう

# Storing Data in Control Flow ~ Goのコルーチン深掘り Night
- 私用で見れなかったぜ