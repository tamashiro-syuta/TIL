# 📝「手を動かしてわかるクリーンアーキテクチャ」のメモ

## 目的
  - 業務で触っているシステムがオニオンアーキテクチャやDDDに近い構成なので、それらの理解を深めるために読む
    - クリーンアーキテクチャと思って書籍買ったけど勘違いだったw
    - まあでも、近い構成だと思うので、エッセンスだけ取り入れたい
  - 今まではMVCフレームワークしか使ったことないので、他のアーキテクチャへの理解を触れてみる

***

# 保守容易性
- 様々ある品質要求において、「保守容易性」が一番重要
  - そのほかの全ての要素に影響を与えるため
- 保守性が低いと変更コストが上がり、エンジニアと非エンジニアの衝突が起きやすくなる
- だから、保守容易性の高いアーキテクチャを採用しようね

***

# 従来の多層アーキテクチャの何が問題なのか？
## 前提
- 保守容易性が重要なので、アーキテクチャはそれを実現するために設計される必要がある
  - 「RLS使いたいからMySQLからPostgreSQLに変えてね〜」って言われても対応できるように
  - 従来のアーキテクチャだとそれが難しい

## 従来の多層アーキテクチャとは
- Web層、ドメイン層、永続化層の3層構成
  - たぶんRailsで言うと、Web層がコントローラ、ドメイン層がモデル、永続化層がDB周り
- 依存の流れは、Web層 👉 ドメイン層 👉 永続化層
- アーキテクチャのルール
  - 上位層は自身と同じかそれ以下の層にアクセスできる
  - 下位層は上位層にアクセスできない(依存の流れに逆らわない)

## 何が問題？
- DB中心のアプローチ
  - DBのスキーマ変更がアプリケーション全体に影響を与える
- DB中心ではアプリを設計する際にDBのスキーマから設計する
  - アプリの目的は特定のドメインの課題を解決すること
  - ってことは本来は、**ドメイン(ビジネスロジック)を中心に設計すべき**
  - ドメインから設計できれば、エンジニアが技術的な要素を無視してドメインの設計に集中できる
  - でも依存の流れで、どうしてもDB中心になってしまう
- 「従来のアーキテクチャ × ORM」でよりDB中心が進む
  - ORMを使うことで、よりドメイン層と永続化層が密結合になりやすい
    1. エンティティが永続化層にある
    2. ドメイン層からエンティティにアクセスできる
    3. ドメイン層が永続化層の関心事まで扱う
        - Railsでもモデルは一般的にビジネスロジック〜DBまでを責務としている
    4. ドメイン層と永続化層が密結合になる
        - ドメイン層のコードに影響を与えずに永続化層のコードを変更するのが難しくなる

  ![従来の多層アーキテクチャ](/image/architecture/clean_architecture_handson/orm_with_mvc_architecture.jpg)

***

# 依存権系の逆転
[ Q ] 依存関係を逆転させてドメイン中心で設計するのはわかったけど、どうやって逆転すんねん。。。

[ A ] SOLID原則の「単一責任の原則」と「依存関係逆転の原則」を使って逆転していくよ♫

クリーンアーキテクチャにおいて、
単一責任の原則はWhy(ベースとなる考え方、なんでそうするのか？)で、
依存性逆転の原則はHow(どうやって実現するのか？)

## 単一責任の原則
- 単一責任の原則 = コンポーネントを変更する理由は、1つだけになるようにすべき
- クリーンアーキテクチャにおける単一責任の原則は「Why?(なんでそうするの?)」
  - ドメイン中心にするには、ドメインが他のコンポーネントに依存しないようにしないとね
  - そのためには、ドメイン層が単一責任の原則を守らないとね
  - 全部の層で依存なしは無理だし、ドメインが中心になるように内部の層にいくにつれて依存を減らしていくよ

## 依存関係逆転の原則
- 依存関係逆転の原則 = コードベース内の依存関係は、いかなるものであっても、その方向を逆転することができる
- クリーンアーキテクチャにおける依存関係逆転の原則は「How?(どうやって依存関係を逆転させるの?)」
  - 逆転させたいコンポーネントの`interface`を内側の層に定義する
  - 外側の層は内側の層の`interface`を実装する
  - そうすることで、層単位で見た時に外側の層が内側の層に依存するようになる

## クリーンアーキテクチャの各層の概要
![clean_architecture](/image/architecture/clean_architecture_handson/clean_architecture.jpg)

### 🟨 エンタープライズビジネスルール層(図の黄色)
- エンティティ
- ドメイン層の中心
- 他の層に依存しない
- ドメインに登場する「概念」を表現する
- ドメインの関心事(ビジネスルール)を実装する
  <details>
    <summary>ユースケースとの違い</summary>

    - エンティティ: アプリケーションの有無に関わらず、業務として行えること
    - ユースケース: アプリケーションの場合にのみ発生すること
  </details>
### 🟥 アプリケーションビジネスルール層(図の赤色)
- エンティティを操作する
- 一般的にサービス層と呼ばれるもの
  - 単一の責任しか持たないように扱うものの粒度をより細かくしたもの
- アプリケーションの関心ごとを実装する

### 🟩 インターフェースアダプタ層(図の緑色)
- ビジネスルールをサポートするもの(コントローラー、ゲートウェイ、プレゼンターなど)
  - 🟥 ユースケース と 🟦 外部のインターフェースをつなぐ役割
  - ex: 永続化、UI、外部接続、デバイス

### 🟦 フレームワーク、ドライバ層(図の青色)
- Web、UI、外部接続、DB、デバイスなど
- 使用しているWebフレームワーク(echoなど)や、データベースドライバなどの外部ライブラリの設定や初期化を行う層
- echo使った際のルートのmain.goもここに当たるよ byGPT

***

# パッケージ構成に関する戦略
- アーキテクチャの構成要素を意識したパッケージ構成がおすすめ
  - 以下は、ヘキサゴナルアーキテクチャのパッケージ構成例
  ```
  adapter/
    ├── in/
    │   └── web/
    │       └── SendMoneyController
    ├── out/
    │   └── persistence/
    │       ├── AccountPersistenceAdapter
    │       └── SpringDataAccountRepository
  application/
    ├── domain/
    │   ├── model/
    │   │   └── Account
    │   └── service/
    │       └── SendMoneyService
    ├── port/
    │   ├── in/
    │   │   └── SendMoneyUseCase
    │   └── out/
    │       └── UpdateAccountStatePort
  common/
  ```
- ほとんどのソフトウェアにおいて、アーキテクチャは単なる抽象的な概念に過ぎなく、コードと直接的に結びつかない
  - そのため、アーキテクチャをコードに落とし込むためには、パッケージ構成を意識した設計が必要
  - そうすることで実装時にアーキテクチャを意識した実装がしやすくなる

***

# ユースケースの実装
- ユースケースに必要な大まかなフロー
    1. 入力値を受け取る
    2. ビジネスルールに関する妥当性を検証する
    3. ドメインモデルの状態を変更する
    4. 出力値を返す

## ユースケースの実装のポイント
### 入力値の妥当性の確認はユースケースの責務ではない
- **ユースケースはビジネスルールの実装に集中する**
- 構文的な妥当性の確認は、ユースケースの外で行う
  - ex: ヘキサゴナルアーキテクチャの場合、`port`ディレクトリに入力モデルを作成し、そこでコンストラクタの引数が正しい入力値かを検証する
  - 入力モデルは基本的にユースケースと1対1の関係になるのが望ましい
  - 使い回しは、単一責任の原則に反するため避ける

### ビジネスルールに関する妥当性の検証はユースケースの責務
- **ユースケースはビジネスルールの実装に集中する(2回目)**
- ビジネスルールに関する妥当性の検証と入力値の妥当性の検証の区別する際の考え方
  - 入力値の妥当性の検証: 構文的にチェックできる、
  - ビジネスルールに関する妥当性の検証: エンティティの状態を利用して行う
  - 以下は、送金処理のユースケース例
    - 入力値の確認: 送金額が0以上か : ビジネスルールは関係ない
    - ビジネスルールの確認: 送金元の残高が送金額以上か : エンティティから値を取得する必要がある

### 出力モデルは必要最低限かつ単一責任の原則を守る
- 出力モデルも基本的にはユースケースと1対1の関係になるのが望ましい
- 出力モデルを使い回す = ほかのユースケースで必要だからと一方にとって不必要なデータまで返すことになる
  - これは単一責任の原則に反する

### `Getter`のみのユースケースの場合、`Getter`用のサービスを作るのもあり
- その際はファイル名に`Query`をつけて、これが`Getter`用のサービスだとわかるようにするのもあり
- 最悪、直接送信ポート層にアクセスする短絡的な実装もギリッギリ許容できなくもない

## 濃いドメインモデル と 薄いドメインモデル の違い
### 濃いドメインモデル
- ドメインロジックはドメインモデル内に集中する
- この場合のユースケースは、ユーザーが何を行おうとしているのかという意図を表現するだけ
  - イメージとしては入力値をドメインモデルに渡すために整形するだけ
  - BFF的な役割になる

### 薄いドメインモデル
- エンティティはフィールドのGetter/Setterしか持たない
- ドメインロジックの実装はユースケースに集中する

### どちらを選ぶべきか？
- 結論、PJ次第
- 逆に言えばどっちでも対応できまっせ

***

# Webアダプタの実装
- Webアダプタの責務はざっくり言うと`Controller` + `middleware`
  1. 送られてきたHTMLのリクエストをプログラムで利用可能なオブジェクトに変換する
  2. 認証/認可を行う
  3. (Webアダプタ層に送られてきた)入力値の妥当性を検証する
  4. 入力値をユースケースに渡す入力モデルに変換する
  5. ユースケースを呼び出す
  6. ユースケースの結果をHTMLのレスポンスに変換する
  7. HTTPレスポンスを送信する
- ユースケースがビジネスロジックに集中できるように、それ以外のHTMLの周りなどの責務をWebアダプタ層が持ってあげてるイメージ

***

# 永続化アダプタの実装
- 永続化アダプタの責務は、通常のDB層と同じ
  1. 入力モデルを受け取る
  2. 受け取った入力モデルをDBに対して操作を行えるもにに変換する
  3. その変換したものを使ってDBを操作する
  4. DBから帰ってきた結果をアプリケーションが扱える出力モデルに変換する
  5. 変換した出力モデルを返す
- 他の層と違うのは **「ポートをどのように分割するか？」**
  - よくある単一テーブルの操作を一つの送信ポートに実装すると、複数のサービスから呼び出しされる際に、そのサービスでは使わないメソッドにも依存することになる
    - ❌ メソッドは使わないのに依存先が増える
    - ❌ テストの際、使っていないメソッドまでモックしないといけない
    - ❌ テストの際、仮に使っていないメソッドはモックせずにいた場合、引き継いだエンジニアが完全にモックされたものと勘違いし、カバーできていないメソッドを新たに作るかもしれない
  - **「必要としないお荷物に依存していると、予期せぬトラブルの元につながるということだ」**
  - **インターフェイス分離の原則** に従って、クライアントの必要最低限のものだけ定義する
    - テーブル単位で実装するのではなく、ユースケース単位で実装する
    - コンテキストごとにフォルダ分けをして、フォルダ名で明示的に担当範囲を示すのも良い
- トランザクションをどこに実装すべき？？
  - 結論、PJによる
    - 個人的にはトランザクションもinterfaceとして定義すれば、依存関係を祖結合にして、別のDBに切り替える時とかにスムーズにできそう。実装していないのでイメージだけど
  - ユースケースに書く場合
    - メリット
      - 簡単に実装できる
    - デメリット
      - アプリケーションの核が汚れる
  - ドランザクションの仕組みを自前で実装
    - メリット
      アプリケーションの核が汚れない
    - デメリット
      - 実装コストが高い
***

# アーキテクチャの構成要素に対するテスト
大体他のアーキテクチャとかと変わらない考え方だったので割愛

***

# 境界を越える際のモデルの変換

***

# アプリケーションの組み立て


***

# 短絡的な実装への意図した選択


***

# アーキテクチャ内の境界の維持


***

# 複数の境界づけられたコンテキストの管理


***

# コンポーネント基盤のアーキテクチャ


***

# アーキテクチャの決定
