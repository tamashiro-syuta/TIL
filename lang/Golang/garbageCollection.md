---
title: "ガベージコレクション"
tags: ["Go"]
---
# 「スタック」と「ヒープ」

## スタック
> スタックは一連のメモリブロックで、実行されるスレッドのすべての関数呼び出しが同じスタックを共有します。スタック上のメモリ割り当ては高速で単純です。
>
> メモリを最後に割り当てた位置は「スタックポインタ」に保存され、追加でメモリを割り当てる際にはスタックポインタを動かすことで割り当てます。
> (中略)
> 新しい変数が定義されるたびにスタックポインタはその変数の値のサイズの分だけ動かされます。
>
> 関数が終了すると、戻り値がスタック経由で呼び出し元の関数に返され、終了した関数のスタックフレームの最初の一までスタックポイントが戻されることで、その関数のローカル変数や引数にしようされていたスタック上のメモリがすべて解放されます。

### 概要
- 関数呼び出しごとに割り当てられる短命のメモリ領域
- データの寿命は関数のスコープ内に限定され、スコープを抜けると自動で解放される
- 高速：メモリの割り当て・解放はシンプル（LIFO構造）
- ガベージコレクション不要：スタック上のメモリは関数の終了とともに解放される
- データのサイズが正確にわかっていないものは、スタックではなく "ヒープ" にデータが保存される(この判断はコンパイラがやるよ)
  - Goは型がキッチリしているから、サイズがわかるよ(ポインタも)

## ヒープ
- ガベージコレクションを行うメモリ領域
- 遅い：ヒープに割り当てたデータはガベージコレクション（GC）によって解放されます。

### ヒープにデータを置かない方が良い理由
- ガベージコレクションの操作にも時間はかかる
  - GCの処理は大きく①処理効率が良いものと、②遅延が少ないもの の2つがある
  - Goでは ②遅延が少ないもの を優先している
  - シンプルに 無駄な作業をなるべく減らして処理早くした方が良くない？ってこと
- 処理が遅くなっちゃうから
  - 構造体へのポインタのスライスはRAM(ランダム・アクセス・メモリ)に散らばって記録されている
  - ランダムだと、アクセスが遅くなる(逐次的(シーケンシャル)な読み出しが一番早い)
  - なんと研究によると2桁遅くなるらしい！！
  - なるべくスタックにデータを寄せれるように、ポインタの参照データもサイズがわかるようにした方が良い

# Goでメモリ効率の良い処理を書くには
- なぜGoがポインタをあまり使わないように進めるのか？
  - スタックに保存されるものをできるだけ多くして、Gcの負荷を減らすため
- Goのイディオムに従った書き方をすると、自然にメモリ最適な処理になる！！🔥
