# 合成型

## 配列
配列は、あまり新しい内容がなかったので割愛。。。

## スライス
- スライスは比較できない
  - 比較しようとするとコンパイルでエラーになるよ
  - スライスを唯一比較できるのは、`nil`のみ
  - `nil`には型がない = どんな型にも代入できるし比較もできる
- スライスが大きくなると、新しい参照先の配列を作成するが、この時のコピーに時間がかかるようになる
  - そのため、スライスのサイズを増やす際は、事前にある程度の余裕を持ってメモリを確保するようになっている
    - Go1.17時点では、キャパシティが1024未満なら2倍、それ以降は1.25倍のキャパシティで確保される
- `make`関数を使ったスライスの作成方法
  - ex) スライスの中身を指定しつつ、キャパシティも指定する方法
    ```go
    s := make([]int, 0, 5)
    s = append(s, 1, 2, 3)
    ```
  - こうすることで、キャパシティは5で、中身は`[1, 2, 3]`のスライスが作成される
- `make`を使ってスライスを作る場面は「スライスのサイズが予測できない時」(予測できれば初期化時に指定指定すれば良いため)
  - スライスを作成する際は **「スライスを大きくする回数を少なくするには？」** を意識することが大事
  - 考えられるシチュエーション
    - バッファとして使うスライス
      - `make`に長さ(正の数)指定する
    - 別のスライスにデータを移す場合
      - 必要なサイズがわかっているので、`make`にそのサイズを指定する
      - ただし、サイズを間違えるとゼロ値が入ったり、パニックを起こしてしまうので注意
    - その他
      - 予測できない場合は、`make`に0を指定しておくのが良い
    - (個人的には、バグを起こさない方が重要だと思うから、困ったら0でいいんじゃないかな〜と思っている)
- **「フルスライス」** を使って、意図しないメモリの書き換えを防げる！！！
  - (前提) スライスは配列を参照しているだけなので、一つのスライスから別のスライスを作成する(サブスライスっていうらしい)と、元のスライスの値も変わってしまう
    - グローバル変数みたいだね〜
  - **フルスライスを使うと、作成するスライスのキャパシティを指定できて、誤って別のメモリを書き換えちゃった！がなくなる**
    ```go
    s := []int{1, 2, 3, 4, 5}
    full := s[:2:3] // [1, 2]のスライスを作成、キャパシティは3
    ```
- メモリを共有しないスライスを作成する方法
  - `copy`関数を使う
    ```go
    s := []int{1, 2, 3, 4, 5}
    c := make([]int, len(s))
    lastNum := copy(c, s) // copy(コピー先, コピー元) ← この例では、sの中身をcにコピーしている（返り値はコピーされた要素数）
    fmt.Println(c, lastNum) // [1, 2, 3, 4, 5] 5
    ```
  - この方法で作成したスライスは、元のスライスとはメモリを共有していないので、元のスライスの値が変わっても影響を受けない
