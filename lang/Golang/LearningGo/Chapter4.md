# ブロック、シャドーイング、制御構造

## ブロック
- `{`と`}`で囲まれた範囲を1つのブロックとして扱う
- 関数の外で定義された変数、定数、型、関数は、パッケージブロックに置かれ、より内側で定義されたブロックからアクセス可能になる
- ? 外側で定義された変数と同じ名前の変数を内側で定義すると？？
  - 内側の変数が優先される = **シャドーイング**
  - [ポイント]
    - 上書きされたのではなく、**優先された**
    - 下のコードにおいて、最初のxと2番目のxは別物
    - ポインタを使ってアクセスすると、それぞれのアドレスが異なることがわかる
    - **シャドーイングは可読性が下がるため、避けた方が良い!!!!!**
    - **パッケージで呼び出したメソッド等も同様にシャドーイングされるので注意**
    ```go
    func main() {
      var x = 100
      if x == 100 {
        fmt.Println(x) // 100
        fmt.Println(&x) // 0xc00009a040
        x := 200
        fmt.Println(x) // 200
        fmt.Println(&x) // 0xc00009a060
      }
      fmt.Println(x) // 100
    }
    ```

## if文
特になかったぜ！！！

## for文
- mapをrangeで回す時は、順番がランダムになるんだって。
- これは、セキュリティの観点から、`HashDos`っていう攻撃ができないようにするためらしい
- 文字列をrangeで回す際、マルチバイトなruneに出会うと、UTF-8の表現を32ビットの数値に変換した値を返す
- **range内の値はコピーなのでrange内で変数を書き換えても元の値は変わらないぜ**

## switch文
- 比較対象を指定しない"ブランクswitch"ってやつもあるよ
  - 要は、`switch`と`{`の間に何も書かなくても動くよってこと
  - ※ ただし、case節には必ず条件式が必要(比較対象がないんだから当たり前っちゃ当たり前だけど)
    ```go
    words := []string{"hi", "salutations", "hello"} //liststart
    for _, word := range words {
      var wordLen = len(word)
      switch { // 比較対象の変数の指定なし
      case 5:
        fmt.Println(word, "は短い単語です")
      case 10:
        fmt.Println(word, "は長すぎる単語です")
      default:
        fmt.Println(word, "はちょうどよい長さの単語です")
      }
    }
    ```
- `fallthrough`を使うと、次のcase節に処理が移る
  - case節の最後の行にこの設定がある場合、次のcase節に処理が移る
  - **※`fallthrough`は使わない方が良い！！！**
    - これを使うってことは、ケース分けがうまくいっていないケースが多いため、注意して使った方が良い
    ```go
    switch {
    case 1 > 0:
      fmt.Println("1 > 0")
      fallthrough
    case 1 < 0:
      fmt.Println("1 < 0")
    }
    ```
- `break`で処理から抜け出す際の注意点
  - そもそも、`fallthrough`と同様の理由で、**`break`を使う場合も気をつけた方が良い**
  - `break`は、`switch`文の中で使うと、`switch`文から抜け出す
  - `for`文の繰り返し処理ごと抜け出したい場合はラベルを使うと良い
    - `break`だけだと、`switch`文から抜け出してしまうのみで、繰り返し処理は続くので注意
    ```go
    func main() {
    loop:  // NOTE: loopというラベルを設定
      for i := 0; i < 10; i++ {
        switch {
        case i%2 == 0:
          fmt.Println(i, "：偶数")
        case i%3 == 0:
          fmt.Println(i, "：3で割り切れるが2では割り切れない")
        case i%7 == 0:
          fmt.Println(i, "：ループ終了！")
          break loop // NOTE: loopラベルを指定して抜け出す
        default:
          fmt.Println(i, "：退屈な数")
        }
      }
    }
    ```

## goto文
- `goto`自体はアンチパターンとして扱われがちだし、実際可読性も落ちると思うので、使わない方が良いと思う。
- Goでは制限を加えてわかりにくくなるコードにする工夫がなされているらしいが、当面は使わなそうだし、一旦飛ばす 🙅‍♀️
