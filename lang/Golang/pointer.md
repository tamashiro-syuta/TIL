---
title: "ポインタ"
tags: ["Go"]
---
# ポインタ の基本
- ポインタは値のメモリアドレスを指す
- 変数 T のポインタは、 `*T` 型で、ゼロ値は `nil`
- `&` 演算子は、そのオペランド(operand)へのポインタを引き出す
  - `&`をつけたら、その変数のアドレスを取得できる
- `*` 演算子は、ポインタの指す先の変数を示す
  - `*`をつけたら、そのポインタが指す先の変数を取得できる
	- 「ポインタで参照しているくせに、その先の値を見るなんて！」ということで、"デリファレンス" とか "参照外し" とか言われているよ
	- nilポインタにでリファレンスするとpanicになるから、デリファレンスする時はnilのハンドリングもしっかりしようね
- 「nilポインタ = 参照先の値がない」ということなので、ミューテーションの関数に入れても意味ないよ、変更する値がないからね
- ポインタは「どのポインタでも必ず同じサイズ」
	- メモリのアドレスを表すので、メモリにどんなサイズのデータが入っていようとアドレスのサイズは変わらないため
	- Q:「とはいえメモリのサイズが増えたら使用するメモリの数も増えるじゃん！そしたらアドレスも変わってくるんじゃないの？」
		- A:「**ポインタに保存されているのは最初のメモリのアドレスのみ**なのです！だから変わらないのです！」
		- 🚨GPTさんの回答なのと、調べてもそれっぽいソースはなかったので、100%正しいとは言えなさそうだけど納得はした
- 実はスライス、マップ、関数、インタフェース、チャネルも全てポインターで実装されているらしい！！
	- スライスは分かるが、関数とかもなのは意外
- ポインタはイミュータブル(変更可能)だよ！！！(当たり前ですが)
	- なので、こいつ変更したいなって時はポインタを引数に取り、変更はしないんだけど値は欲しい(なんかの条件に沿ってbool返す時とか)は値を取るのが良い
	- 返り値に**structの中の値を変更したい時とかはポインタ型を返そう**、そうでない場合は値でかえそう

```go
package main

import "fmt"

func main() {
	i, j := 42, 2701

	p := &i         // NOTE 変数iのアドレス(ポイント)を取得
	fmt.Println(p)  // NOTE 変数iのアドレス(ポイント)を表示 ex: 0xc0000160e0
	fmt.Println(*p) // NOTE ポインタを経由して変数iの値(42)を表示
	*p = 21         // NOTE ポインタを経由して変数iに21を代入
	fmt.Println(i)  // NOTE 変数iの値が21になっていることを確認

	p = &j         // NOTE 変数jのアドレス(ポイント)を取得
	*p = *p / 37   // NOTE ポインタを経由して変数jに2701/37を代入(変数jの値を書き換えるのではなく、変数jのポインタを経由して変数jのメモリアドレスを取得し、直接値を書き換えて、結果としてjの値も変わっている、変数とポインタが同じメモリアドレスを参照しており、参照先をポインタ経由で変更したので変数jの値も変更されている)
	fmt.Println(j) // NOTE 変数jの値が73になっていることを確認
}
```

## Tips
- リテラルをデリファレンスしようとするとエラーになる
	- これは、リテラルは**コンパイル時に値が確定し、その値が直接コードに埋め込まれるので、メモリに値が格納されない**ため
	- ポインタは値のメモリアドレスを参照するものなので、メモリにないリテラルは参照できない
	- 対応策として、ヘルパー関数を利用しよう！
	  - 以下の例では、実行時に引数`s`がメモリ上にコピーされるので参照可能になる
	  ```go
		func stringp(s string) *string {
			return *s
		}
		```
- ポインタ型をレシーバに持つメソッドにおいて、レシーバがnilの場合、構造体をレシーバに代入してもnilのまま
  - ポインタはあくまでアドレスを持っているだけ。参照先がnilなら、それに何をしてもnilのまま。書き換える先のアドレスがないから当たり前っちゃ当たり前だけど
  - 値を返したい場合は、新しく構造体を作って返す。そうでない場合はエラーを返そう

***

# ポインタレシーバ
ポインタレシーバでメソッドを宣言できます。

これはレシーバの型が、ある型 T への構文 *T があることを意味します。 （なお、 T は *int のようなポインタ自身を取ることはできません）

例では *Vertex に Scale メソッドが定義されています。

ポインタレシーバを持つメソッド(ここでは Scale )は、レシーバが指す変数を変更できます。 レシーバ自身を更新することが多いため、変数レシーバよりもポインタレシーバの方が一般的です。

Scale の宣言(line 16)から * を消し、プログラムの振る舞いがどう変わるのかを確認してみましょう。

変数レシーバでは、 Scale メソッドの操作は元の Vertex 変数のコピーを操作します。 （これは関数の引数としての振るまいと同じです）。 つまり main 関数で宣言した Vertex 変数を変更するためには、Scale メソッドはポインタレシーバにする必要があるのです。

```go
package main

import (
	"fmt"
	"math"
)

type Vertex struct {
	X, Y float64
}

// NOTE: Absメソッドは値レシーバを使用
func (v Vertex) Abs() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

// NOTE: Scaleメソッドはポインタレシーバを使用
// NOTE: 返り値はなく、レシーバの値(ポインタが指す値)を直接更新している
func (v *Vertex) Scale(f float64) {
	v.X = v.X * f
	v.Y = v.Y * f
}

func main() {
	v := Vertex{3, 4}
	v.Scale(10) // NOTE: vのXとYを10倍にスケーリング
	fmt.Println(v.Abs()) // NOTE: スケーリング後のvの長さを計算して表示（50.0）
}
```

下のコードで、Scale関数を以下のように `*`を削除すると、Scale関数内での変更が反映されない。

**理由は、Scale関数内での変更が、main関数で宣言したVertex変数のコピーを操作しているため。(ポインタを渡すことで、元の変数を操作することができる)**
```go
func (v Vertex) Scale(f float64) {
	// NOTE: この場合はScaleに渡したvそのものではなく、コピーされたvを操作している = 元のvは変更されない()
	v.X = v.X * f
	v.Y = v.Y * f
}
```


## ポインタレシーバがよく使われる理由
1. パフォーマンス
    - 大きな構造体を値レシーバで渡すとコピーが発生し、パフォーマンスが低下する可能性がある。
		- ポインタレシーバは、ポインタを渡すだけなので効率的。
		  ```go
			type Vertex struct {
				X, Y float64
			}

			func (v Vertex) Move() {
					v.X += 10
					v.Y += 10
			}

			func main() {
					v := Vertex{3, 4}
					v.Move()
					// NOTE: {3, 4} と表示される => 値の参照ではなく、コピーされている = その分メモリを消費している
					fmt.Println(v)
			}
			```
2. 変更を許可する
    - ポインタレシーバを使うと、メソッド内でレシーバのフィールドを変更できる。
		- 例えば、Scaleメソッドのようにオブジェクトの状態を変更する必要がある場合に便利。

## 値レシーバが使われる場合
1. 構造体が小さい
    - 構造体が小さく、コピーのコストが低い場合。
		- 値レシーバは変更しない意図を明示的に示すことができる。
2. 変更しないメソッド
    - レシーバのフィールドを変更しないメソッドでは値レシーバを使うことが多い。

***

# ポインタをメソッドで使う

下の2つの呼び出しを比べると、ポインタを引数に取る ScaleFunc 関数は、ポインタを渡す必要があることに気がつくでしょう。

```go
var v Vertex
ScaleFunc(v, 5)  // Compile error!
ScaleFunc(&v, 5) // OK
```
メソッドがポインタレシーバである場合、呼び出し時に、変数、または、ポインタのいずれかのレシーバとして取ることができます。

```go
var v Vertex
v.Scale(5)  // OK
p := &v
p.Scale(10) // OK
v.Scale(5)
```

のステートメントでは、 v は変数であり、ポインタではありません。 メソッドでポインタレシーバが自動的に呼びだされます。 Scale メソッドはポインタレシーバを持つ場合、Goは利便性のため、 v.Scale(5) のステートメントを (&v).Scale(5) として解釈します。

| 呼び出しの種類                  | レシーバ/引数    | 呼び出し方                      | 例                              |
|-------------------------------|----------------|----------------------------|-------------------------------|
| 関数の引数としての呼び出し        | ポインタ         | 明示的にポインタを渡す必要がある         | `ScaleFunc(&v, 10)`            |
| 値レシーバのメソッド呼び出し       | 値              | 値で呼び出し可能                | `v.Abs()`                     |
| ポインタレシーバのメソッド呼び出し  | ポインタまたは値 | ポインタまたは値で呼び出し可能（自動変換） | `v.Scale(2)` または `p.Scale(3)` |


```go
package main

import "fmt"

type Vertex struct {
	X, Y float64
}

func (v *Vertex) Scale(f float64) {
	v.X = v.X * f
	v.Y = v.Y * f
}

func ScaleFunc(v *Vertex, f float64) {
	v.X = v.X * f
	v.Y = v.Y * f
}

func main() {
	v := Vertex{3, 4}
	// NOTE: ポインタレシーバなので、よしなに解釈してくれる
	v.Scale(2)
	// NOTE: 関数なので、明示的にポインタを渡す必要がある
	ScaleFunc(&v, 10)

	p := &Vertex{4, 3}
	// NOTE: ポインタレシーバなので、よしなに解釈してくれる
	p.Scale(3)
	ScaleFunc(p, 8)

	fmt.Println(v, p)
}
```

引数の場合も同様なんだぜ！

```go
package main

import (
	"fmt"
	"math"
)

type Vertex struct {
	X, Y float64
}

func (v Vertex) Abs() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func AbsFunc(v Vertex) float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func main() {
	v := Vertex{3, 4}
	fmt.Println(v.Abs())
	fmt.Println(AbsFunc(v))

	p := &Vertex{4, 3}
	fmt.Println(p.Abs())
	// NOTE: `*` を削除して、`AbsFunc(p)` のようにするとコンパイルエラー
	fmt.Println(AbsFunc(*p))
}
```
