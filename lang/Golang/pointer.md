---
title: "ポインタ"
tags: ["Go"]
---
# ポインタ の基本
- ポインタは値のメモリアドレスを指す
- 変数 T のポインタは、 `*T` 型で、ゼロ値は `nil`
- `&` 演算子は、そのオペランド(operand)へのポインタを引き出す
  - `&`をつけたら、その変数のアドレスを取得できる
- `*` 演算子は、ポインタの指す先の変数を示す
  - `*`をつけたら、そのポインタが指す先の変数を取得できる
- 使う場面としては、以下らしい by GPT-4o
  - 関数に渡す引数
    > Goでは関数に引数を渡す際、デフォルトでは値渡し（値のコピー）が行われます。大きな構造体やデータを関数に渡すとき、値渡しはメモリと処理のオーバーヘッドを生じさせます。このため、ポインタを使ってデータのアドレスを渡すことで、関数内で直接データを操作できます。
  - 可変データ構造の操作
    > スライスやマップなどの可変データ構造に対して操作を行う場合、ポインタを使うことで直接データを操作できます。
  - 共有データの更新
    > 複数のゴルーチン（goroutine）間でデータを共有する場合、ポインタを使うことで共有データを安全かつ効率的に操作できます。特に、同期メカニズム（例：チャネルやミューテックス）を使用する場合に有効です。

```go
package main

import "fmt"

func main() {
	i, j := 42, 2701

	p := &i         // NOTE 変数iのアドレス(ポイント)を取得
	fmt.Println(p)  // NOTE 変数iのアドレス(ポイント)を表示 ex: 0xc0000160e0
	fmt.Println(*p) // NOTE ポインタを経由して変数iの値(42)を表示
	*p = 21         // NOTE ポインタを経由して変数iに21を代入
	fmt.Println(i)  // NOTE 変数iの値が21になっていることを確認

	p = &j         // NOTE 変数jのアドレス(ポイント)を取得
	*p = *p / 37   // NOTE ポインタを経由して変数jに2701/37を代入(変数jの値を書き換えるのではなく、変数jのポインタを経由して変数jのメモリアドレスを取得し、直接値を書き換えて、結果としてjの値も変わっている、変数とポインタが同じメモリアドレスを参照しており、参照先をポインタ経由で変更したので変数jの値も変更されている)
	fmt.Println(j) // NOTE 変数jの値が73になっていることを確認
}
```

***

# ポインタレシーバ
ポインタレシーバでメソッドを宣言できます。

これはレシーバの型が、ある型 T への構文 *T があることを意味します。 （なお、 T は *int のようなポインタ自身を取ることはできません）

例では *Vertex に Scale メソッドが定義されています。

ポインタレシーバを持つメソッド(ここでは Scale )は、レシーバが指す変数を変更できます。 レシーバ自身を更新することが多いため、変数レシーバよりもポインタレシーバの方が一般的です。

Scale の宣言(line 16)から * を消し、プログラムの振る舞いがどう変わるのかを確認してみましょう。

変数レシーバでは、 Scale メソッドの操作は元の Vertex 変数のコピーを操作します。 （これは関数の引数としての振るまいと同じです）。 つまり main 関数で宣言した Vertex 変数を変更するためには、Scale メソッドはポインタレシーバにする必要があるのです。

```go
package main

import (
	"fmt"
	"math"
)

type Vertex struct {
	X, Y float64
}

// NOTE: Absメソッドは値レシーバを使用
func (v Vertex) Abs() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

// NOTE: Scaleメソッドはポインタレシーバを使用
// NOTE: 返り値はなく、レシーバの値(ポインタが指す値)を直接更新している
func (v *Vertex) Scale(f float64) {
	v.X = v.X * f
	v.Y = v.Y * f
}

func main() {
	v := Vertex{3, 4}
	v.Scale(10) // NOTE: vのXとYを10倍にスケーリング
	fmt.Println(v.Abs()) // NOTE: スケーリング後のvの長さを計算して表示（50.0）
}
```

下のコードで、Scale関数を以下のように `*`を削除すると、Scale関数内での変更が反映されない。

**理由は、Scale関数内での変更が、main関数で宣言したVertex変数のコピーを操作しているため。(ポインタを渡すことで、元の変数を操作することができる)**
```go
func (v Vertex) Scale(f float64) {
	// NOTE: この場合はScaleに渡したvそのものではなく、コピーされたvを操作している = 元のvは変更されない()
	v.X = v.X * f
	v.Y = v.Y * f
}
```


## ポインタレシーバがよく使われる理由
1. パフォーマンス
    - 大きな構造体を値レシーバで渡すとコピーが発生し、パフォーマンスが低下する可能性がある。
		- ポインタレシーバは、ポインタを渡すだけなので効率的。
		  ```go
			type Vertex struct {
				X, Y float64
			}

			func (v Vertex) Move() {
					v.X += 10
					v.Y += 10
			}

			func main() {
					v := Vertex{3, 4}
					v.Move()
					// NOTE: {3, 4} と表示される => 値の参照ではなく、コピーされている = その分メモリを消費している
					fmt.Println(v)
			}
			```
2. 変更を許可する
    - ポインタレシーバを使うと、メソッド内でレシーバのフィールドを変更できる。
		- 例えば、Scaleメソッドのようにオブジェクトの状態を変更する必要がある場合に便利。

## 値レシーバが使われる場合
1. 構造体が小さい
    - 構造体が小さく、コピーのコストが低い場合。
		- 値レシーバは変更しない意図を明示的に示すことができる。
2. 変更しないメソッド
    - レシーバのフィールドを変更しないメソッドでは値レシーバを使うことが多い。

***

# ポインタをメソッドで使う

下の2つの呼び出しを比べると、ポインタを引数に取る ScaleFunc 関数は、ポインタを渡す必要があることに気がつくでしょう。

```go
var v Vertex
ScaleFunc(v, 5)  // Compile error!
ScaleFunc(&v, 5) // OK
```
メソッドがポインタレシーバである場合、呼び出し時に、変数、または、ポインタのいずれかのレシーバとして取ることができます。

```go
var v Vertex
v.Scale(5)  // OK
p := &v
p.Scale(10) // OK
v.Scale(5)
```

のステートメントでは、 v は変数であり、ポインタではありません。 メソッドでポインタレシーバが自動的に呼びだされます。 Scale メソッドはポインタレシーバを持つ場合、Goは利便性のため、 v.Scale(5) のステートメントを (&v).Scale(5) として解釈します。

| 呼び出しの種類                  | レシーバ/引数    | 呼び出し方                      | 例                              |
|-------------------------------|----------------|----------------------------|-------------------------------|
| 関数の引数としての呼び出し        | ポインタ         | 明示的にポインタを渡す必要がある         | `ScaleFunc(&v, 10)`            |
| 値レシーバのメソッド呼び出し       | 値              | 値で呼び出し可能                | `v.Abs()`                     |
| ポインタレシーバのメソッド呼び出し  | ポインタまたは値 | ポインタまたは値で呼び出し可能（自動変換） | `v.Scale(2)` または `p.Scale(3)` |


```go
package main

import "fmt"

type Vertex struct {
	X, Y float64
}

func (v *Vertex) Scale(f float64) {
	v.X = v.X * f
	v.Y = v.Y * f
}

func ScaleFunc(v *Vertex, f float64) {
	v.X = v.X * f
	v.Y = v.Y * f
}

func main() {
	v := Vertex{3, 4}
	// NOTE: ポインタレシーバなので、よしなに解釈してくれる
	v.Scale(2)
	// NOTE: 関数なので、明示的にポインタを渡す必要がある
	ScaleFunc(&v, 10)

	p := &Vertex{4, 3}
	// NOTE: ポインタレシーバなので、よしなに解釈してくれる
	p.Scale(3)
	ScaleFunc(p, 8)

	fmt.Println(v, p)
}
```

引数の場合も同様なんだぜ！

```go
package main

import (
	"fmt"
	"math"
)

type Vertex struct {
	X, Y float64
}

func (v Vertex) Abs() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func AbsFunc(v Vertex) float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func main() {
	v := Vertex{3, 4}
	fmt.Println(v.Abs())
	fmt.Println(AbsFunc(v))

	p := &Vertex{4, 3}
	fmt.Println(p.Abs())
	// NOTE: `*` を削除して、`AbsFunc(p)` のようにするとコンパイルエラー
	fmt.Println(AbsFunc(*p))
}
```
