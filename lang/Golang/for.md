---
title: "for文"
tags: ["Go"]
---
# for の基本
> 基本的に、 for ループはセミコロン ; で3つの部分に分かれています:
>
> 初期化ステートメント: 最初のイテレーション(繰り返し)の前に初期化が実行されます
> 条件式: イテレーション毎に評価されます
> 後処理ステートメント: イテレーション毎の最後に実行されます
> 初期化ステートメントは、短い変数宣言によく利用します。その変数は for ステートメントのスコープ内でのみ有効です。


- これが基本の形
- 初期化、後処理ステートメント、セミコロン(;)は省略できる
```go
package main

import "fmt"

func main() {
	sum := 0
	for i := 0; i < 10; i++ {
		fmt.Println(sum, i)
		sum += i
	}
	fmt.Println(sum)
}
```

- 初期化、後処理ステートメント、セミコロン(;)を省略したver (いわゆるwhile文っぽく書ける！)
```go
package main

import "fmt"

func main() {
	sum := 1
	for sum < 1000; {
		sum += sum
	}
	fmt.Println(sum)
}
```

# Range
- for ループに利用する range は、スライスや、マップ( map )をひとつずつ反復処理するために使う
- スライスをrangeで繰り返す場合、rangeは反復毎に2つの変数を返す
	- 1つ目 : 変数はインデックス( index )
	- 2つ目 : インデックスの場所の要素のコピー

```go
package main

import "fmt"

var pow = []int{1, 2, 4, 8, 16, 32, 64, 128}

func main() {
	for i, v := range pow {
		fmt.Printf("2**%d = %d\n", i, v)

		// NOTE: rangeで取得できるvalue(変数v)はコピーなので、元の配列には影響を与えない
		v = 1
	}

	fmt.Printf("%v\n", pow)
}


// NOTE: 出力結果
// 2**0 = 1
// 2**1 = 2
// 2**2 = 4
// 2**3 = 8
// 2**4 = 16
// 2**5 = 32
// 2**6 = 64
// 2**7 = 128
// [1 2 4 8 16 32 64 128] ← rangeで取得できるvalue(変数v)はコピーなので、元の配列には影響を与えない
```

- mapをrangeで回す時は、順番がランダムになるんだって。
- これは、セキュリティの観点から、`HashDos`っていう攻撃ができないようにするためらしい
- 文字列をrangeで回す際、マルチバイトなruneに出会うと、UTF-8の表現を32ビットの数値に変換した値を返す
- **range内の値はコピーなのでrange内で変数を書き換えても元の値は変わらないぜ**
