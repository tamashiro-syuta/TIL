---
title: "package"
tags: ["Go"]
---
# パッケージのimport
>Goでは、最初の文字が大文字で始まる名前は、外部のパッケージから参照できるエクスポート（公開）された名前( exported name )です。 例えば、 Pi は math パッケージでエクスポートされています。

> 小文字ではじまる pi や hoge などはエクスポートされていない名前です。

- `math.pi` はエラーになる
  - piなんて知らないぞってなる。exportは必ず大文字から始まるので
- `math.Pi` はエラーにならない
- そういえば、`fmt.Println()`の`Println`も大文字から始まっている

```go
package main

// NOTE: パッケージのimportでは、イアのようにまとめてグループ化して書くのが一般的らしい
import (
	"fmt"
	"math"
)

func main() {
	fmt.Println(math.Pi)
}
```

- packageのimportはパス名ではなく、package名が使われる
```go
// /hoge.go
package huga

func Huga() {
	// 何らかの処理
}

// 呼び出し側
package main

import (
	// ~~
)

func main() {
	huga.Huga() // package名を指定(パスではない)
}
```

# 内部パッケージ
- 「複数のパッケージで共有したいけどAPIとして外部に提供したい訳ではないんだよな〜」の時に使える
- Goでは `internal`ディレクトリ配下のモジュールは全て内部パッケージになり、複数のパッケージで共有できるが、APIとして外部に提供されなくなる
  - (感想)だから、いろんなリポジトリでinternalって命名してたのか


# go.modとかgo.sumって何してんねん
- go.modはざっくり言うと、package.json的なやつ
- go.sumには以下の情報が含まれる
  - モジュールとそのバージョン、モジュールのチェックサム(ハッシュ値)
    - このモジュールのこのバージョンを使っているよ
  - そのモジュールのgo.modファイルのチェックサム
    - そのモジュールが何を使っているかわかるよ
- `go.mod`に`indirect`って書かれているのは「お前が必要なモジュールimportしてなかったから、こっちで勝手に入れといたで」ってやつ
- 複数のモジュールが同じモジュールの異なるバージョンに依存していた場合
  - 原則、新しいバージョンが優先される
  - **異なるマイナーバージョンをimportはしない！**
  - **ただし、メジャーバージョンが違えば、importできる**
    - パスが違うから
	- メジャーバージョンが2以上の場合、importでメジャーバージョンを指定するのが慣習
	  - ex: `github.com/hoge/huga/v3`
  - 同一のマイナーバージョンで動作しない場合は、モジュールの開発者に直してもらう
    - 非互換性を良しとしないGoっぽい考え方

# ベンダリング
- モジュールが常に同一の依存関係でビルドできるように、依存関係をコピーしておくこと
- `go mod vendor`でルートに`vendor`ディレクトリが作成される
- メリット
  - サードパーティのどのコードが使われているかが把握できる
- デメリット
  - リポジトリのサイズがデカくなる

# プロキシサーバ と チェックサムデータベース
- Goは非中央集権的だが、Googleはプロキシサーバと、チェックサムデータベースは管理をしている

## プロキシサーバ
- パブリックなGoのモジュールの全バージョンをコピーしている
- `go get`した際は、このプロキシを経由してフェッチしている
- そのおかげでモジュールがインターネットから削除されてしまうのを防ぐ
- 環境変数`GOPROXY`を`direct`に設定することで、プロキシを経由せず直接フェッチすることもできる

## チェックサムデータベース
- 全てのモジュールの全バージョンのチェックサムを含む`go.sum`とその関連情報を保持している
- モジュールが改ざんされるのを防ぐ
