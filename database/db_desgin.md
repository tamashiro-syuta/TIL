# 達人に学ぶDB設計徹底指南書

## 知りたいこと
- DB設計(モデル設計)のアンチパターンとベストプラクティス
  - 物理設計はそこまで要らない(だいたいフルマネージドなクラウド使うことが多いから)
- 今まで設計してきたDBの設計がどれくらい正しいかを知りたい
  - 同時に良くなかった設計があれば、どう改善できたか知りたい

***

## はじめに と おわりに の要約
- 論理設計と物理設計はどちらも大事でトレードオフの関係
- だが、優先するべきは論理設計
  - 物理設計はハードの品質が上がれば解決されるが、論理設計はそうはいかない
- 基本は論理設計が優先だけど、パフォーマンスがシビアな時には物理設計も考慮して設計した方が良いよね

***

## 第1章 データベースを制する者はシステムを制す
- DOA >>> POA
  - DOA(Data Oriented Approach): データを中心に設計しようね、データは一元管理しようね
    - プログラミングする前に、まずはDBの設計から!!!
  - POA(Process Oriented Approach): プロセスを中心に設計しようね
    - まずはプログラムを書いて、DBの設計は後回し!!!
  - 言わずもがなだが、DB設計の方が大事。プログラムよりDB設計の方が変更しにくいし、長生きだからちゃんと作っていた方が良い

### 3層スキーマ
- 外部スキーマ: ビュー
  - ユーザーが見るデータみたいなイメージ
  - レコードの一部だけを取り出して表示する的なやつ
    - ex) テーブル的にはA,B,Cの3つのカラムがあるけど、ビュー的にはAだけを表示する。この時、ユーザーから見えるデータ(外部スキーマ)はAだけ
  - Railsでいうところの`view`のこと
- 概念スキーマ: テーブル
  - 開発者が意識しているスキーマ
  - Railsでいうところの`schema.rb`のこと
  - テーブル構成、テーブル同士の関係などを定義
  - 概念スキーマは、外部スキーマと内部スキーマの間に位置し、緩衝材のような役割を果たす = "データ独立性"
    - 外部スキーマ(ユーザーに見せるデータ)を変更したい！ → 概念スキーマから取り出す値を変更するだけでOK
    - 内部スキーマを変更したい!(データの保持の仕方) → 概念スキーマは変更せず、内部スキーマだけ変更すればOK(概念スキーマの定義通りであればどう保持しようがOK)
- 内部スキーマ: ファイル
  - RDBMSから見たスキーマ
  - 開発者が定義した概念スキーマをDB内部ではどのように保存しているか？を定義しているスキーマ

***

## 第2章 論理設計と物理設計
- **DBの性能問題は、8割はストレージのI/Oによって起きている!!!**

### パフォーマンスのサイジング
- 性能要件は以下の2つの指標で定義される
  - 処理時間: 「○秒以内に処理が終了するか」= 時間
  - スループット: 「一定時間内でどれだけ早く処理できるか」= スピード
- システムの初期段階では、性能要件を定義するのは難しいため、以下の定義方法がおすすめ
  1. 類似の稼働中システムから流用
    - 簡単だけど、類似度合いで精度が変わる
  2. プロトタイプで性能検証
    - 正確だが、コストがかかる

### ストレージの冗長構成
- RAID = 冗長化(副作用で性能向上)
  - パフォーマンスの原因であるディスクI/Oも、アクセスが分散されるので性能向上にもなる
- 冗長化する際の検討事項
  - 「そもそも、冗長化する必要ってある？」
    - する必要ないシステムに適用するとコストが上がるだけ
  - 「どんくらい冗長化する？」
    - RAID 0
      - 冗長化しないけど、ディスクは増やすから性能は上がるよ
    - RAID 1
      - ミラーリング(同じデータを2本のディスクそれぞれに保存)
      - データの信頼性が上がる(性能は変わらない)
    - RAID 5
      - 通称 パリティ分散
      - なんかよくわからんけど、「パリティ」ってやつに情報いれてデータを復元できるようにするらしい
      - 最低でも3本のディスクが必要
      - 冗長化しつつ、性能も向上する
    - RAID 10
      - RAID 1 + RAID 0
      - 最低でも4本のディスクが必要
      - ミラーリング + ストライピング で性能と信頼性を両立させる
- RAIDの採用基準
  - 最低でもRAID 5。お金に余裕があればRAID10。
  - RAID 0は論外
***

## 第3章 論理設計と正規化
### 外部キー
  - 親テーブルのレコードを削除した場合、関連する子テーブルの扱いをどうするか？
    - railsでは以下のオプションがある
    - `:destroy` :  親と一緒に子レコードも削除する。（無理心中パターン）
    - `:delete_all` :  親と一緒に子レコードも削除する。ただし、直接DBのレコードを削除するので、子レコードのコールバック処理は実行されない。
    - `:nullify` :  子レコードの外部キーを NULL 更新する。（みなしごパターン）
    - `:restrict_with_exception` : 子レコードがある場合は ActiveRecord::DeleteRestrictionError が発生する。（引き留めパターン）
    - `:restrict_with_error` :  子レコードがある場合は削除できず、親レコードにエラー情報が付加される。（引き留めパターン）
  - 理想は **「常に子テーブルを先に削除なり変更して、後から親テーブルを更新する」** = "親より子を優先して動こうね"

### 3.5正規形(ボイス-コッド正規形)
- ボイス-コッド正規形(BCNF)は、第3正規形と第4正規形の間に位置する正規形
  - より厳密な第3正規形
- 「非キーからキーへの関数従属をなくした状態」
  - 第3正規形: 違うレベルの従属を排除する(推移的関数従属)
    - ex: この会社で、この社員IDってことは、この部署IDだよね、ってことは、部署名は〇〇だよね
    - ↑ これでは、会社と社員ID → 部署ID → 部署名 という関係がある(`部署ID → 部署名`は別テーブルに切り出そう)
  - ボイス-コッド正規形: 非キーからキーへの関数従属を排除する
    - ex: (正規化前)この社員IDってことは、この部署IDだよね、ってことは 部署のサブリーダーは〇〇さんだよね
      - ↑ リーダー(`非キー`)と部署(`キー`)は従属関係にある！ ※部分関数従属や推移的関数従属ではない
  - 問題点
    - **①: 部署のサブリーダーが変わった時、複数行の更新が発生**
    - **②: 社員が部署に入るまで、サブリーダーと部署の関連を登録できない**
    - **③: 社員が部署から外れた際にレコードを削除すると、サブリーダーとのチームの関連を削除される危険がある**
      - (正規化後): 社員-部署テーブルと、部署-サブリーダーテーブルに分割することで解決
      - **原因: 多対多の関係を正規化しようとした!!(正規化は基本的に1対多出ないといけない)**

### 第4正規形・第5正規形
- **中間テーブルでは3つ以上のテーブルの関連を表現するな → 必ず2つのテーブル(1つの関連)に押さえろ**

### 正規化についてのまとめ
- 設計する側はドメイン知識も必要！！！
  - 正規化の肝である「従属性」は、ドメイン知識がないと正しいかわからないため
- どこまで正規化するべき？？
  - 第3正規形 + 多対多の時は中間テーブルを1テーブル1関連に押さえる
  - ↑ Railsでの基本的な考え方と同じっぽい
  - **テーブル数が増え、パフォーマンスが悪化するデメリットがあるが、正しくデータを保持することのほうが大切**

***

## 第4章 ER図 ~複数のテーブルの関係を表現する~

ER図の読み書きだったので、割愛

***

## 第5章 論理設計とパフォーマンス ~正規化の欠点と非正規化~
前提 : **正規化とパフォーマンスは強いトレードオフの関係**

### 原因
- 正規化をする = テーブルを分割する = テーブル結合が増える →→→ **パフォーマンスが悪化する**
  - joinはDBへの負荷が大きい(計算量が多いから)

### 対策
#### SQLをチューニングする = joinは受け入れて、それ以外で負荷を軽減する
- まずはこっちを検討！！！
- インデックスを貼る
- クエリを最適化する

#### 非正規化 = joinさせないようにあえて正規化しない
- **※ 履歴データなどの更新が少ないデータに対しては有効な手段**
- メリット
  - joinがないので、パフォーマンスが向上する
- デメリット
  - 更新時のパフォーマンス
    - 履歴データでもデータが更新されることがある
    - 非正規化したデータの更新は、正規化したデータに比べて複雑になる(考慮する点が多い = 不整合になりやすい)
  - データのリアルタイム性
    - 更新したデータをどのタイミングで反映させるか？(非正規化したデータは、正規化したデータと同期させる必要がある)
    - ビジネス要件的に、どの程度リアルタイム性を求めるかの調整が必要。
  - 改修コストの大きさ
    - DOA(データ中心アプローチ)なので、途中からデータの構造を変えたいんですけど〜となると激ムズ
- これでも、メリットの方を優先するなら、非正規化もあり！！！

#### 非正規化する際のポイント
- ① 必要最低限のデータ + ドメインで利用するデータ(計算値など)
  - 必要最低限のデータ = 正規化状態に戻せるデータ
  - ドメインで利用するデータ = ドメイン側で必要となるデータ
    - ex: 注文履歴テーブルに注文数を残す
    - 注文情報から計算されるデータを使いたい場合はINSERT時に計算してデータとして保存しておく
- ② あえて子テーブルに冗長なカラムを持たせる
  - 非正規化できない(どうしても1対多になる)場合は、子テーブルに冗長なカラムを持たせる
    - ex: 注文詳細テーブルに、注文テーブルと同じカラムを持たせて、検索時のjoinを省略する

#### 設計時のポイント
著者のお言葉🙏
> 論理設計を担当する人間は、正規系の理論を理解しているだけでなく、それによって生じる様々なトレードオフを知り尽くした上で、あらゆる要件を同時に満たせる平衡点を探し出せる能力が必要

***

## 第6章 データベースとパフォーマンス

***

## 第7章 論理設計のバッドノウハウ

***

## 第8章 論理設計のグレーノウハウ

***

## 第9章 一歩進んだ論理設計 ~SQLで木構造を扱う~
