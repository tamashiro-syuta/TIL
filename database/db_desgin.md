# 達人に学ぶDB設計徹底指南書

## 知りたいこと
- DB設計(モデル設計)のアンチパターンとベストプラクティス
  - 物理設計はそこまで要らない(だいたいフルマネージドなクラウド使うことが多いから)
- 今まで設計してきたDBの設計がどれくらい正しいかを知りたい
  - 同時に良くなかった設計があれば、どう改善できたか知りたい

***

## はじめに と おわりに の要約
- 論理設計と物理設計はどちらも大事でトレードオフの関係
- だが、優先するべきは論理設計
  - 物理設計はハードの品質が上がれば解決されるが、論理設計はそうはいかない
- 基本は論理設計が優先だけど、パフォーマンスがシビアな時には物理設計も考慮して設計した方が良いよね

***

## 第1章 データベースを制する者はシステムを制す
- DOA >>> POA
  - DOA(Data Oriented Approach): データを中心に設計しようね、データは一元管理しようね
    - プログラミングする前に、まずはDBの設計から!!!
  - POA(Process Oriented Approach): プロセスを中心に設計しようね
    - まずはプログラムを書いて、DBの設計は後回し!!!
  - 言わずもがなだが、DB設計の方が大事。プログラムよりDB設計の方が変更しにくいし、長生きだからちゃんと作っていた方が良い

### 3層スキーマ
- 外部スキーマ: ビュー
  - ユーザーが見るデータみたいなイメージ
  - レコードの一部だけを取り出して表示する的なやつ
    - ex) テーブル的にはA,B,Cの3つのカラムがあるけど、ビュー的にはAだけを表示する。この時、ユーザーから見えるデータ(外部スキーマ)はAだけ
  - Railsでいうところの`view`のこと
- 概念スキーマ: テーブル
  - 開発者が意識しているスキーマ
  - Railsでいうところの`schema.rb`のこと
  - テーブル構成、テーブル同士の関係などを定義
  - 概念スキーマは、外部スキーマと内部スキーマの間に位置し、緩衝材のような役割を果たす = "データ独立性"
    - 外部スキーマ(ユーザーに見せるデータ)を変更したい！ → 概念スキーマから取り出す値を変更するだけでOK
    - 内部スキーマを変更したい!(データの保持の仕方) → 概念スキーマは変更せず、内部スキーマだけ変更すればOK(概念スキーマの定義通りであればどう保持しようがOK)
- 内部スキーマ: ファイル
  - RDBMSから見たスキーマ
  - 開発者が定義した概念スキーマをDB内部ではどのように保存しているか？を定義しているスキーマ

***

## 第2章 論理設計と物理設計
- **DBの性能問題は、8割はストレージのI/Oによって起きている!!!**

### パフォーマンスのサイジング
- 性能要件は以下の2つの指標で定義される
  - 処理時間: 「○秒以内に処理が終了するか」= 時間
  - スループット: 「一定時間内でどれだけ早く処理できるか」= スピード
- システムの初期段階では、性能要件を定義するのは難しいため、以下の定義方法がおすすめ
  1. 類似の稼働中システムから流用
    - 簡単だけど、類似度合いで精度が変わる
  2. プロトタイプで性能検証
    - 正確だが、コストがかかる

### ストレージの冗長構成
- RAID = 冗長化(副作用で性能向上)
  - パフォーマンスの原因であるディスクI/Oも、アクセスが分散されるので性能向上にもなる
- 冗長化する際の検討事項
  - 「そもそも、冗長化する必要ってある？」
    - する必要ないシステムに適用するとコストが上がるだけ
  - 「どんくらい冗長化する？」
    - RAID 0
      - 冗長化しないけど、ディスクは増やすから性能は上がるよ
    - RAID 1
      - ミラーリング(同じデータを2本のディスクそれぞれに保存)
      - データの信頼性が上がる(性能は変わらない)
    - RAID 5
      - 通称 パリティ分散
      - なんかよくわからんけど、「パリティ」ってやつに情報いれてデータを復元できるようにするらしい
      - 最低でも3本のディスクが必要
      - 冗長化しつつ、性能も向上する
    - RAID 10
      - RAID 1 + RAID 0
      - 最低でも4本のディスクが必要
      - ミラーリング + ストライピング で性能と信頼性を両立させる
- RAIDの採用基準
  - 最低でもRAID 5。お金に余裕があればRAID10。
  - RAID 0は論外
***

## 第3章 論理設計と正規化
### 外部キー
  - 親テーブルのレコードを削除した場合、関連する子テーブルの扱いをどうするか？
    - railsでは以下のオプションがある
    - `:destroy` :  親と一緒に子レコードも削除する。（無理心中パターン）
    - `:delete_all` :  親と一緒に子レコードも削除する。ただし、直接DBのレコードを削除するので、子レコードのコールバック処理は実行されない。
    - `:nullify` :  子レコードの外部キーを NULL 更新する。（みなしごパターン）
    - `:restrict_with_exception` : 子レコードがある場合は ActiveRecord::DeleteRestrictionError が発生する。（引き留めパターン）
    - `:restrict_with_error` :  子レコードがある場合は削除できず、親レコードにエラー情報が付加される。（引き留めパターン）
  - 理想は **「常に子テーブルを先に削除なり変更して、後から親テーブルを更新する」** = "親より子を優先して動こうね"

### 3.5正規形(ボイス-コッド正規形)
- ボイス-コッド正規形(BCNF)は、第3正規形と第4正規形の間に位置する正規形
  - より厳密な第3正規形
- 「非キーからキーへの関数従属をなくした状態」
  - 第3正規形: 違うレベルの従属を排除する(推移的関数従属)
    - ex: この会社で、この社員IDってことは、この部署IDだよね、ってことは、部署名は〇〇だよね
    - ↑ これでは、会社と社員ID → 部署ID → 部署名 という関係がある(`部署ID → 部署名`は別テーブルに切り出そう)
  - ボイス-コッド正規形: 非キーからキーへの関数従属を排除する
    - ex: (正規化前)この社員IDってことは、この部署IDだよね、ってことは 部署のサブリーダーは〇〇さんだよね
      - ↑ リーダー(`非キー`)と部署(`キー`)は従属関係にある！ ※部分関数従属や推移的関数従属ではない
  - 問題点
    - **①: 部署のサブリーダーが変わった時、複数行の更新が発生**
    - **②: 社員が部署に入るまで、サブリーダーと部署の関連を登録できない**
    - **③: 社員が部署から外れた際にレコードを削除すると、サブリーダーとのチームの関連を削除される危険がある**
      - (正規化後): 社員-部署テーブルと、部署-サブリーダーテーブルに分割することで解決
      - **原因: 多対多の関係を正規化しようとした!!(正規化は基本的に1対多出ないといけない)**

### 第4正規形・第5正規形
- **中間テーブルでは3つ以上のテーブルの関連を表現するな → 必ず2つのテーブル(1つの関連)に押さえろ**

### 正規化についてのまとめ
- 設計する側はドメイン知識も必要！！！
  - 正規化の肝である「従属性」は、ドメイン知識がないと正しいかわからないため
- どこまで正規化するべき？？
  - 第3正規形 + 多対多の時は中間テーブルを1テーブル1関連に押さえる
  - ↑ Railsでの基本的な考え方と同じっぽい
  - **テーブル数が増え、パフォーマンスが悪化するデメリットがあるが、正しくデータを保持することのほうが大切**

***

## 第4章 ER図 ~複数のテーブルの関係を表現する~

ER図の読み書きだったので、割愛

***

## 第5章 論理設計とパフォーマンス ~正規化の欠点と非正規化~
前提 : **正規化とパフォーマンスは強いトレードオフの関係**

### 原因
- 正規化をする = テーブルを分割する = テーブル結合が増える →→→ **パフォーマンスが悪化する**
  - joinはDBへの負荷が大きい(計算量が多いから)

### 対策
#### SQLをチューニングする = joinは受け入れて、それ以外で負荷を軽減する
- まずはこっちを検討！！！
- インデックスを貼る
- クエリを最適化する

#### 非正規化 = joinさせないようにあえて正規化しない
- **※ 履歴データなどの更新が少ないデータに対しては有効な手段**
- メリット
  - joinがないので、パフォーマンスが向上する
- デメリット
  - 更新時のパフォーマンス
    - 履歴データでもデータが更新されることがある
    - 非正規化したデータの更新は、正規化したデータに比べて複雑になる(考慮する点が多い = 不整合になりやすい)
  - データのリアルタイム性
    - 更新したデータをどのタイミングで反映させるか？(非正規化したデータは、正規化したデータと同期させる必要がある)
    - ビジネス要件的に、どの程度リアルタイム性を求めるかの調整が必要。
  - 改修コストの大きさ
    - DOA(データ中心アプローチ)なので、途中からデータの構造を変えたいんですけど〜となると激ムズ
- これでも、メリットの方を優先するなら、非正規化もあり！！！

#### 非正規化する際のポイント
- ① 必要最低限のデータ + ドメインで利用するデータ(計算値など)
  - 必要最低限のデータ = 正規化状態に戻せるデータ
  - ドメインで利用するデータ = ドメイン側で必要となるデータ
    - ex: 注文履歴テーブルに注文数を残す
    - 注文情報から計算されるデータを使いたい場合はINSERT時に計算してデータとして保存しておく
- ② あえて子テーブルに冗長なカラムを持たせる
  - 非正規化できない(どうしても1対多になる)場合は、子テーブルに冗長なカラムを持たせる
    - ex: 注文詳細テーブルに、注文テーブルと同じカラムを持たせて、検索時のjoinを省略する

#### 設計時のポイント
著者のお言葉🙏
> 論理設計を担当する人間は、正規系の理論を理解しているだけでなく、それによって生じる様々なトレードオフを知り尽くした上で、あらゆる要件を同時に満たせる平衡点を探し出せる能力が必要

***

## 第6章 データベースとパフォーマンス
- **「インデックス」と「統計情報」を駆使しろ！！！**

### インデックス
- だいたいインデックスといったらB-treeインデックスのことを指す
- B-treeインデックスは、オールランダー！！！

#### B-treeインデックスの紹介
- メリット
  - **均一性 : 検索速度にバラつきがない**
    - 平衡木と呼ばれる構造により、どの値を取得する場合でも同じ高さ = どの値でも速度にバラつきがない
  - **持続性 : データ量の増加してもパフォーマンスが劣化しにくい**
    - データ量の増加に対して、計算量の増加が緩やかなため、データ量が増えてもパフォーマンスが劣化しにくい
      - フルスキャン: 全データを1件ずつ検索 → O(N)の計算量
      - B-tree: データを半分に分けて値を取り出す操作を繰り返す → O(logN)の計算量
      - 詳しくはゆるコンピュータ科学ラジオのDB回を見よう！！
  - **処理汎用性 : CRUD操作のどれでもそこそこ速い**
    - これは説明読んでもよくわからなかった
    - 検索と同じで、O(logN)の計算量で処理できるらしいです
  - **非等値生 : 不等号使ってもそこそこ速い**
    - データを半分にぶった斬って範囲を絞っていくので、不等号でもそこそこ速い
  - **親ソート性 : ソート処理も高速**
    - インデックス構築時にソートして並べてあるので、負荷が高いソート処理もやらずに検索できる
      - 【ちなみに】
      - ソートが高負荷なのは、大量のソートが起きた場合はメモリにデータが載らず、ディスクI/Oが発生するため
      - ディスクは基本的に永続的なデータを保存しておくための場所で高速な処理が向いていない
      - そいつに書き込みさせているから、重くなる
      - スポーツでいえば、人数トラブルで本来のポジションにいない選手を使っているようなもの

#### B-treeインデックスの設計方針
- 大規模なテーブル
  - データ量が少ないうちは速度はあまり変わらない
  - **目安は1万件** ← 実務で役立ちそうなTipsだな！！！！！！！！！
- カーディナリティが高いカラム
  - カーディナリティが高い = 種類豊富 ex: ユーザーID
  - カーディナリティが低い = 種類が少ない ex: bool値
  - 【カーディナリティの注意点】
    - カーディナリティが高くても、分布に偏りがある場合は意味ない！
    - データを効率よく探すためのインデックスなのに偏りがあったら、データを分割して探すのが難しくなる
      - 「あれ？分割しても全然、特定できないじゃ〜ん」ってなる
    - 複合インデックス(複数列をまとめて1つのインデックスとする)場合、
      - カーディナリティが高いカラムを先に持ってくるインデックスの効率が上がる(先に計算されるから)
      - 複数のカラムの組み合わせがカーディナリティになる
        - A,B,Cの3つのカラムが、それぞれ2通り、3通り、4通りの値を持つ場合、複合インデックスのカーディナリティは 2 * 3 * 4 = 24通り
- 頻繁に検索されるカラム or 結合条件に使われるカラム
- インデックスの張りすぎは逆効果
  - インデックスは内部的には実際のテーブルとは別の場所に保存されている
  - 実データを更新する = インデックスも更新する必要がある
  - **インデックスが多いと、必要な更新処理が増え、パフォーマンスが悪化する**
- 定期的にメンテしろよな
  - 定期的にインデックスの貼り直しをすることで、パフォーマンスを維持できる

#### インデックスを効かないクエリ
- インデックス列で演算している or 関数に利用している
  - ダメな例: `where price * 1.1 = '10'`
  - 良い例: `where price = '10' / 1.1`
  - **あくまでインデックスが貼られているのは、`price`であって、計算値ではない**
- `IS NULL`を使っている
  - インデックスを張っている列でも、`NULL`にはインデックスは貼られていない(ことが多い)
- 否定系を使っている
  - 〇〇以外を取得する = B-treeを使って絞り込みができない(できても範囲が馬鹿でかいので無理ゲー)
- ORを使っている
  - ダメな例: `where price = '10' OR price = '20'`
  - 良い例: `where price IN ('10', '20')`
  - `OR`もインデックスが効かない
  - 代わりに`IN`を使おう！！！！！
- LIKE検索で、中間一致 or 後方一致を使っている
  - ダメな例: `where name like '%〇〇'`
  - 良い例: `where name like '〇〇%'`
  - **インデックスは前方一致のみ効く！！！**
  - 中間一致や後方一致は、計算量がバカクソ増える
- 暗黙の型変換
  - ダメな例: `where price = '10'` ※ priceがint型の場合
  - 良い例: `where price = 10`
  - 列と異なる型で検索しても実行はできるがインデックスは効かない

#### インデックスの注意点


### 統計情報
- 【そもそも】SQLは統計情報をもとに実行計画を決定する
  - RDBにおける統計情報はカーナビにとっての地図的な存在!!
  - 地図(統計情報)が古いと、最短経路で行けない！！(効率悪くなっちゃうぜ！！)
  - 人間ができるのも、統計情報を更新することくらい(どの経路がデータを取るかもだいたい機械に任せた方が高効率)
- 人間にできることは ①統計情報の収集タイミングを決めること と ②収集対象を決めること

#### ①統計情報の収集タイミングを決めること
- データが大きく変更したタイミングになるはやで！！！
- でも、負荷も大きいし時間もかかるから夜間バッチが良いかも！！
- 収集を自動でやってくれるDBもあるが、DBの種類によっていないやつもある
  - RDBは手動らしい！！！(GPI曰く)
#### ②収集対象を決めること
- 大きく変更されたデータを対象に！！！
- 逆に統計情報を凍結させる場合もある
  - ほぼデータが変わらない場合は、統計情報を凍結させる(変更しない)ことで、パフォーマンスを保つことができる(なかなかそんなサービスはないが)

***

## 第7章 論理設計のバッドノウハウ
よくあるアンチパターンの紹介(当たり前だったり、新しく得られた知見がないやつは割愛)

### 非スカラ値 で保存
- 非スカラ値 = 配列やJSONなど
- データを保存するときは、可能な限り分解して保存するのが良い。
  - ex: メールアドレスも、ドメイン部分とユーザー部分に分解して保存すると🙆‍♀️
  - 後から、ドメインに応じたデータの取得などがしやすくなる(逆に結合していると、処理が面倒になる)
- やらないと思うが、RDBMSによっては配列型というカラムを持つ場合があるので、あっても使うなよ！！！
- JSON型は、ユースケースにおいてはわんちゃんあり
  - 有効なユースケースは、以下。詳しくは[こちら(`database/unti_pattern.md`)](https://github.com/tamashiro-syuta/TIL/blob/main/database/unti_pattern.md#%E3%81%AA%E3%82%93%E3%81%A7%E3%82%82json)を参照
    - ユーザーのカスタマイズ可能な設定
    - ログの保存
    - メタデータの保存
    - などなど

### 単一参照テーブル = DB設計におけるポリモーフィズム
- DB設計において「ポリモーフィズム」はアンチパターン
- このアンチパターンの本質は、**責務が違うテーブルを1つにまとめているところ**
- DB設計においても、**「単一責任の原則」** は大事！！！
- 「データ構造が同じだから」という理由で1つのテーブルにまとめると、以下のデメリットが生じる
  - SQLでどのテーブルかの指定を間違えても返る値が変更されるだけでエラーにならないため、バグが起きても気づきにくい
  - ER図はスッキリするが、モデルとして正確性を欠いているので、可読性は下がる
  - ユースケースによってはレコード数がかえって多くなり、パフォーマンスが低下する
- Railsの`ActiveStorage`ではDB設計レベルでポリモーフィズムを採用しているが、これはあくまで「モデルにファイルをアタッチする」という目的でテーブルをまとめたものであり、単一責任の原則に反していないため、デメリットは最小限に抑えられている(どのモデルにおいても横断的関心事になりうる)

***

## 第8章 論理設計のグレーノウハウ

***

## 第9章 一歩進んだ論理設計 ~SQLで木構造を扱う~
